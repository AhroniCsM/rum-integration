{"ast":null,"code":"import { CORALOGIX_LOGS_URL_SUFFIX, CX_MAPPED_SPAN } from '../constants';\nimport { BATCH_TIME_DELAY } from '../session/session.consts';\nimport { ExportResultCode } from '@opentelemetry/core';\nimport { getSdkConfig, getSessionManager } from '../helpers';\nimport { MAX_RUM_EVENTS_PER_REQUEST } from '../session/sessionWithError.consts';\nimport { Request } from '../Request';\nimport { isSessionWithError } from '../session/session.helper';\nimport { isProcessorShouldStop } from './processor.helper';\nexport class CoralogixExporter {\n  constructor() {\n    this.isActive = true;\n    this.sdkConfig = getSdkConfig();\n    this.request = new Request({\n      suffix: CORALOGIX_LOGS_URL_SUFFIX,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    this.batchTimeDelay = BATCH_TIME_DELAY;\n    this.invokeLogRequest = (logs, markCachedLogsSent) => {\n      if (logs === null || logs === void 0 ? void 0 : logs.length) {\n        this.request.send(JSON.stringify({\n          logs,\n          skip_enrichment_with_ip: !this.sdkConfig.collectIPData\n        })).then(() => {\n          if (markCachedLogsSent) {\n            getSessionManager().cachedLogsSent = true;\n          }\n        });\n      }\n    };\n  }\n  export(spans, resultCallback) {\n    if (isProcessorShouldStop(this.isActive)) {\n      resultCallback({\n        code: ExportResultCode.SUCCESS\n      });\n      return;\n    }\n    const currentSpans = spans.reduce((cxSpans, span) => {\n      if (span[CX_MAPPED_SPAN]) {\n        cxSpans.push(span[CX_MAPPED_SPAN]);\n      }\n      return cxSpans;\n    }, []);\n    if (isSessionWithError()) {\n      this.handleSessionWithError(currentSpans);\n    } else {\n      this.invokeLogRequest(currentSpans);\n    }\n    resultCallback({\n      code: ExportResultCode.SUCCESS\n    });\n  }\n  handleSessionWithError(currentSpans) {\n    const {\n      maxRumEventsForSessionWithError,\n      instrumentationsToSend,\n      sessionHasError\n    } = getSessionManager();\n    const instrumentationLogs = [];\n    currentSpans = currentSpans.reduce((cxSpans, current) => {\n      if (instrumentationsToSend && instrumentationsToSend[current.text.cx_rum.event_context.type]) {\n        instrumentationLogs.push(current);\n      } else {\n        cxSpans.push(current);\n      }\n      return cxSpans;\n    }, []);\n    this.invokeLogRequest(instrumentationLogs);\n    const cachedLogs = window.cachedLogs = [...(window.cachedLogs || []), ...currentSpans];\n    const logsCounter = cachedLogs.length;\n    //check if we reached the limit of max rum events for session with error\n    if (logsCounter > maxRumEventsForSessionWithError && !sessionHasError) {\n      this.clearCachedDataForSessionWithError();\n    } else if (sessionHasError) {\n      if (logsCounter > MAX_RUM_EVENTS_PER_REQUEST) {\n        //split request to chunks of 500 logs per each\n        const chunks = [];\n        for (let i = 0; i < logsCounter; i += MAX_RUM_EVENTS_PER_REQUEST) {\n          chunks.push(cachedLogs.slice(i, i + MAX_RUM_EVENTS_PER_REQUEST));\n        }\n        chunks.forEach(chunk => {\n          setTimeout(() => this.invokeLogRequest(chunk, true), this.batchTimeDelay);\n          this.batchTimeDelay += BATCH_TIME_DELAY;\n        });\n        this.clearCachedDataForSessionWithError();\n      } else {\n        this.invokeLogRequest(cachedLogs, true);\n        this.clearCachedDataForSessionWithError();\n      }\n    }\n  }\n  clearCachedDataForSessionWithError() {\n    window.cachedLogs = [];\n    this.batchTimeDelay = BATCH_TIME_DELAY;\n  }\n  shutdown() {\n    this.isActive = false;\n    return Promise.resolve();\n  }\n}","map":{"version":3,"names":["CORALOGIX_LOGS_URL_SUFFIX","CX_MAPPED_SPAN","BATCH_TIME_DELAY","ExportResultCode","getSdkConfig","getSessionManager","MAX_RUM_EVENTS_PER_REQUEST","Request","isSessionWithError","isProcessorShouldStop","CoralogixExporter","constructor","isActive","sdkConfig","request","suffix","headers","batchTimeDelay","invokeLogRequest","logs","markCachedLogsSent","length","send","JSON","stringify","skip_enrichment_with_ip","collectIPData","then","cachedLogsSent","export","spans","resultCallback","code","SUCCESS","currentSpans","reduce","cxSpans","span","push","handleSessionWithError","maxRumEventsForSessionWithError","instrumentationsToSend","sessionHasError","instrumentationLogs","current","text","cx_rum","event_context","type","cachedLogs","window","logsCounter","clearCachedDataForSessionWithError","chunks","i","slice","forEach","chunk","setTimeout","shutdown","Promise","resolve"],"sources":["../../../../../libs/browser/src/processors/CoralogixExporter.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}