{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { trace, TraceFlags, isSpanContextValid, isValidSpanId, isValidTraceId, INVALID_TRACEID, INVALID_SPANID, INVALID_SPAN_CONTEXT } from '@opentelemetry/api';\nexport var AWSXRAY_TRACE_ID_HEADER = 'x-amzn-trace-id';\nvar TRACE_HEADER_DELIMITER = ';';\nvar KV_DELIMITER = '=';\nvar TRACE_ID_KEY = 'Root';\nvar TRACE_ID_LENGTH = 35;\nvar TRACE_ID_VERSION = '1';\nvar TRACE_ID_DELIMITER = '-';\nvar TRACE_ID_DELIMITER_INDEX_1 = 1;\nvar TRACE_ID_DELIMITER_INDEX_2 = 10;\nvar TRACE_ID_FIRST_PART_LENGTH = 8;\nvar PARENT_ID_KEY = 'Parent';\nvar SAMPLED_FLAG_KEY = 'Sampled';\nvar IS_SAMPLED = '1';\nvar NOT_SAMPLED = '0';\n/**\n * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n * Tracing header spec</a>\n *\n * An example AWS Xray Tracing Header is shown below:\n * X-Amzn-Trace-Id: Root=1-5759e988-bd862e3fe1be46a994272793;Parent=53995c3f42cd8ad8;Sampled=1\n */\nvar AWSXRayPropagator = /** @class */function () {\n  function AWSXRayPropagator() {}\n  AWSXRayPropagator.prototype.inject = function (context, carrier, setter) {\n    var _a;\n    var spanContext = (_a = trace.getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();\n    if (!spanContext || !isSpanContextValid(spanContext)) return;\n    var otTraceId = spanContext.traceId;\n    var timestamp = otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH);\n    var randomNumber = otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n    var parentId = spanContext.spanId;\n    var samplingFlag = (TraceFlags.SAMPLED & spanContext.traceFlags) === TraceFlags.SAMPLED ? IS_SAMPLED : NOT_SAMPLED;\n    // TODO: Add OT trace state to the X-Ray trace header\n    var traceHeader = \"Root=1-\" + timestamp + \"-\" + randomNumber + \";Parent=\" + parentId + \";Sampled=\" + samplingFlag;\n    setter.set(carrier, AWSXRAY_TRACE_ID_HEADER, traceHeader);\n  };\n  AWSXRayPropagator.prototype.extract = function (context, carrier, getter) {\n    var spanContext = this.getSpanContextFromHeader(carrier, getter);\n    if (!isSpanContextValid(spanContext)) return context;\n    return trace.setSpan(context, trace.wrapSpanContext(spanContext));\n  };\n  AWSXRayPropagator.prototype.fields = function () {\n    return [AWSXRAY_TRACE_ID_HEADER];\n  };\n  AWSXRayPropagator.prototype.getSpanContextFromHeader = function (carrier, getter) {\n    var headerKeys = getter.keys(carrier);\n    var relevantHeaderKey = headerKeys.find(function (e) {\n      return e.toLowerCase() === AWSXRAY_TRACE_ID_HEADER;\n    });\n    if (!relevantHeaderKey) {\n      return INVALID_SPAN_CONTEXT;\n    }\n    var traceHeader = getter.get(carrier, relevantHeaderKey);\n    if (!traceHeader || typeof traceHeader !== 'string') {\n      return INVALID_SPAN_CONTEXT;\n    }\n    var pos = 0;\n    var trimmedPart;\n    var parsedTraceId = INVALID_TRACEID;\n    var parsedSpanId = INVALID_SPANID;\n    var parsedTraceFlags = null;\n    while (pos < traceHeader.length) {\n      var delimiterIndex = traceHeader.indexOf(TRACE_HEADER_DELIMITER, pos);\n      if (delimiterIndex >= 0) {\n        trimmedPart = traceHeader.substring(pos, delimiterIndex).trim();\n        pos = delimiterIndex + 1;\n      } else {\n        //last part\n        trimmedPart = traceHeader.substring(pos).trim();\n        pos = traceHeader.length;\n      }\n      var equalsIndex = trimmedPart.indexOf(KV_DELIMITER);\n      var value = trimmedPart.substring(equalsIndex + 1);\n      if (trimmedPart.startsWith(TRACE_ID_KEY)) {\n        parsedTraceId = AWSXRayPropagator._parseTraceId(value);\n      } else if (trimmedPart.startsWith(PARENT_ID_KEY)) {\n        parsedSpanId = AWSXRayPropagator._parseSpanId(value);\n      } else if (trimmedPart.startsWith(SAMPLED_FLAG_KEY)) {\n        parsedTraceFlags = AWSXRayPropagator._parseTraceFlag(value);\n      }\n    }\n    if (parsedTraceFlags === null) {\n      return INVALID_SPAN_CONTEXT;\n    }\n    var resultSpanContext = {\n      traceId: parsedTraceId,\n      spanId: parsedSpanId,\n      traceFlags: parsedTraceFlags,\n      isRemote: true\n    };\n    if (!isSpanContextValid(resultSpanContext)) {\n      return INVALID_SPAN_CONTEXT;\n    }\n    return resultSpanContext;\n  };\n  AWSXRayPropagator._parseTraceId = function (xrayTraceId) {\n    // Check length of trace id\n    if (xrayTraceId.length !== TRACE_ID_LENGTH) {\n      return INVALID_TRACEID;\n    }\n    // Check version trace id version\n    if (!xrayTraceId.startsWith(TRACE_ID_VERSION)) {\n      return INVALID_TRACEID;\n    }\n    // Check delimiters\n    if (xrayTraceId.charAt(TRACE_ID_DELIMITER_INDEX_1) !== TRACE_ID_DELIMITER || xrayTraceId.charAt(TRACE_ID_DELIMITER_INDEX_2) !== TRACE_ID_DELIMITER) {\n      return INVALID_TRACEID;\n    }\n    var epochPart = xrayTraceId.substring(TRACE_ID_DELIMITER_INDEX_1 + 1, TRACE_ID_DELIMITER_INDEX_2);\n    var uniquePart = xrayTraceId.substring(TRACE_ID_DELIMITER_INDEX_2 + 1, TRACE_ID_LENGTH);\n    var resTraceId = epochPart + uniquePart;\n    // Check the content of trace id\n    if (!isValidTraceId(resTraceId)) {\n      return INVALID_TRACEID;\n    }\n    return resTraceId;\n  };\n  AWSXRayPropagator._parseSpanId = function (xrayParentId) {\n    return isValidSpanId(xrayParentId) ? xrayParentId : INVALID_SPANID;\n  };\n  AWSXRayPropagator._parseTraceFlag = function (xraySampledFlag) {\n    if (xraySampledFlag === NOT_SAMPLED) {\n      return TraceFlags.NONE;\n    }\n    if (xraySampledFlag === IS_SAMPLED) {\n      return TraceFlags.SAMPLED;\n    }\n    return null;\n  };\n  return AWSXRayPropagator;\n}();\nexport { AWSXRayPropagator };","map":{"version":3,"names":["trace","TraceFlags","isSpanContextValid","isValidSpanId","isValidTraceId","INVALID_TRACEID","INVALID_SPANID","INVALID_SPAN_CONTEXT","AWSXRAY_TRACE_ID_HEADER","TRACE_HEADER_DELIMITER","KV_DELIMITER","TRACE_ID_KEY","TRACE_ID_LENGTH","TRACE_ID_VERSION","TRACE_ID_DELIMITER","TRACE_ID_DELIMITER_INDEX_1","TRACE_ID_DELIMITER_INDEX_2","TRACE_ID_FIRST_PART_LENGTH","PARENT_ID_KEY","SAMPLED_FLAG_KEY","IS_SAMPLED","NOT_SAMPLED","AWSXRayPropagator","prototype","inject","context","carrier","setter","spanContext","_a","getSpan","otTraceId","traceId","timestamp","substring","randomNumber","parentId","spanId","samplingFlag","SAMPLED","traceFlags","traceHeader","set","extract","getter","getSpanContextFromHeader","setSpan","wrapSpanContext","fields","headerKeys","keys","relevantHeaderKey","find","e","toLowerCase","get","pos","trimmedPart","parsedTraceId","parsedSpanId","parsedTraceFlags","length","delimiterIndex","indexOf","trim","equalsIndex","value","startsWith","_parseTraceId","_parseSpanId","_parseTraceFlag","resultSpanContext","isRemote","xrayTraceId","charAt","epochPart","uniquePart","resTraceId","xrayParentId","xraySampledFlag","NONE"],"sources":["/Users/aharon.shahar/Desktop/tasks/NodeJS/coralogix-frontend/node_modules/@opentelemetry/propagator-aws-xray/src/AWSXRayPropagator.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  trace,\n  Context,\n  TextMapPropagator,\n  SpanContext,\n  TraceFlags,\n  TextMapSetter,\n  TextMapGetter,\n  isSpanContextValid,\n  isValidSpanId,\n  isValidTraceId,\n  INVALID_TRACEID,\n  INVALID_SPANID,\n  INVALID_SPAN_CONTEXT,\n} from '@opentelemetry/api';\n\nexport const AWSXRAY_TRACE_ID_HEADER = 'x-amzn-trace-id';\n\nconst TRACE_HEADER_DELIMITER = ';';\nconst KV_DELIMITER = '=';\n\nconst TRACE_ID_KEY = 'Root';\nconst TRACE_ID_LENGTH = 35;\nconst TRACE_ID_VERSION = '1';\nconst TRACE_ID_DELIMITER = '-';\nconst TRACE_ID_DELIMITER_INDEX_1 = 1;\nconst TRACE_ID_DELIMITER_INDEX_2 = 10;\nconst TRACE_ID_FIRST_PART_LENGTH = 8;\n\nconst PARENT_ID_KEY = 'Parent';\n\nconst SAMPLED_FLAG_KEY = 'Sampled';\nconst IS_SAMPLED = '1';\nconst NOT_SAMPLED = '0';\n\n/**\n * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n * Tracing header spec</a>\n *\n * An example AWS Xray Tracing Header is shown below:\n * X-Amzn-Trace-Id: Root=1-5759e988-bd862e3fe1be46a994272793;Parent=53995c3f42cd8ad8;Sampled=1\n */\nexport class AWSXRayPropagator implements TextMapPropagator {\n  inject(context: Context, carrier: unknown, setter: TextMapSetter) {\n    const spanContext = trace.getSpan(context)?.spanContext();\n    if (!spanContext || !isSpanContextValid(spanContext)) return;\n\n    const otTraceId = spanContext.traceId;\n    const timestamp = otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH);\n    const randomNumber = otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n\n    const parentId = spanContext.spanId;\n    const samplingFlag =\n      (TraceFlags.SAMPLED & spanContext.traceFlags) === TraceFlags.SAMPLED\n        ? IS_SAMPLED\n        : NOT_SAMPLED;\n    // TODO: Add OT trace state to the X-Ray trace header\n\n    const traceHeader = `Root=1-${timestamp}-${randomNumber};Parent=${parentId};Sampled=${samplingFlag}`;\n    setter.set(carrier, AWSXRAY_TRACE_ID_HEADER, traceHeader);\n  }\n\n  extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    const spanContext = this.getSpanContextFromHeader(carrier, getter);\n    if (!isSpanContextValid(spanContext)) return context;\n\n    return trace.setSpan(context, trace.wrapSpanContext(spanContext));\n  }\n\n  fields(): string[] {\n    return [AWSXRAY_TRACE_ID_HEADER];\n  }\n\n  private getSpanContextFromHeader(\n    carrier: unknown,\n    getter: TextMapGetter\n  ): SpanContext {\n    const headerKeys = getter.keys(carrier);\n    const relevantHeaderKey = headerKeys.find(e => {\n      return e.toLowerCase() === AWSXRAY_TRACE_ID_HEADER;\n    });\n    if (!relevantHeaderKey) {\n      return INVALID_SPAN_CONTEXT;\n    }\n    const traceHeader = getter.get(carrier, relevantHeaderKey);\n\n    if (!traceHeader || typeof traceHeader !== 'string') {\n      return INVALID_SPAN_CONTEXT;\n    }\n\n    let pos = 0;\n    let trimmedPart: string;\n    let parsedTraceId = INVALID_TRACEID;\n    let parsedSpanId = INVALID_SPANID;\n    let parsedTraceFlags = null;\n    while (pos < traceHeader.length) {\n      const delimiterIndex = traceHeader.indexOf(TRACE_HEADER_DELIMITER, pos);\n      if (delimiterIndex >= 0) {\n        trimmedPart = traceHeader.substring(pos, delimiterIndex).trim();\n        pos = delimiterIndex + 1;\n      } else {\n        //last part\n        trimmedPart = traceHeader.substring(pos).trim();\n        pos = traceHeader.length;\n      }\n      const equalsIndex = trimmedPart.indexOf(KV_DELIMITER);\n\n      const value = trimmedPart.substring(equalsIndex + 1);\n\n      if (trimmedPart.startsWith(TRACE_ID_KEY)) {\n        parsedTraceId = AWSXRayPropagator._parseTraceId(value);\n      } else if (trimmedPart.startsWith(PARENT_ID_KEY)) {\n        parsedSpanId = AWSXRayPropagator._parseSpanId(value);\n      } else if (trimmedPart.startsWith(SAMPLED_FLAG_KEY)) {\n        parsedTraceFlags = AWSXRayPropagator._parseTraceFlag(value);\n      }\n    }\n    if (parsedTraceFlags === null) {\n      return INVALID_SPAN_CONTEXT;\n    }\n    const resultSpanContext: SpanContext = {\n      traceId: parsedTraceId,\n      spanId: parsedSpanId,\n      traceFlags: parsedTraceFlags,\n      isRemote: true,\n    };\n    if (!isSpanContextValid(resultSpanContext)) {\n      return INVALID_SPAN_CONTEXT;\n    }\n    return resultSpanContext;\n  }\n\n  private static _parseTraceId(xrayTraceId: string): string {\n    // Check length of trace id\n    if (xrayTraceId.length !== TRACE_ID_LENGTH) {\n      return INVALID_TRACEID;\n    }\n\n    // Check version trace id version\n    if (!xrayTraceId.startsWith(TRACE_ID_VERSION)) {\n      return INVALID_TRACEID;\n    }\n\n    // Check delimiters\n    if (\n      xrayTraceId.charAt(TRACE_ID_DELIMITER_INDEX_1) !== TRACE_ID_DELIMITER ||\n      xrayTraceId.charAt(TRACE_ID_DELIMITER_INDEX_2) !== TRACE_ID_DELIMITER\n    ) {\n      return INVALID_TRACEID;\n    }\n\n    const epochPart = xrayTraceId.substring(\n      TRACE_ID_DELIMITER_INDEX_1 + 1,\n      TRACE_ID_DELIMITER_INDEX_2\n    );\n    const uniquePart = xrayTraceId.substring(\n      TRACE_ID_DELIMITER_INDEX_2 + 1,\n      TRACE_ID_LENGTH\n    );\n    const resTraceId = epochPart + uniquePart;\n\n    // Check the content of trace id\n    if (!isValidTraceId(resTraceId)) {\n      return INVALID_TRACEID;\n    }\n\n    return resTraceId;\n  }\n\n  private static _parseSpanId(xrayParentId: string): string {\n    return isValidSpanId(xrayParentId) ? xrayParentId : INVALID_SPANID;\n  }\n\n  private static _parseTraceFlag(xraySampledFlag: string): TraceFlags | null {\n    if (xraySampledFlag === NOT_SAMPLED) {\n      return TraceFlags.NONE;\n    }\n    if (xraySampledFlag === IS_SAMPLED) {\n      return TraceFlags.SAMPLED;\n    }\n    return null;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SACEA,KAAK,EAILC,UAAU,EAGVC,kBAAkB,EAClBC,aAAa,EACbC,cAAc,EACdC,eAAe,EACfC,cAAc,EACdC,oBAAoB,QACf,oBAAoB;AAE3B,OAAO,IAAMC,uBAAuB,GAAG,iBAAiB;AAExD,IAAMC,sBAAsB,GAAG,GAAG;AAClC,IAAMC,YAAY,GAAG,GAAG;AAExB,IAAMC,YAAY,GAAG,MAAM;AAC3B,IAAMC,eAAe,GAAG,EAAE;AAC1B,IAAMC,gBAAgB,GAAG,GAAG;AAC5B,IAAMC,kBAAkB,GAAG,GAAG;AAC9B,IAAMC,0BAA0B,GAAG,CAAC;AACpC,IAAMC,0BAA0B,GAAG,EAAE;AACrC,IAAMC,0BAA0B,GAAG,CAAC;AAEpC,IAAMC,aAAa,GAAG,QAAQ;AAE9B,IAAMC,gBAAgB,GAAG,SAAS;AAClC,IAAMC,UAAU,GAAG,GAAG;AACtB,IAAMC,WAAW,GAAG,GAAG;AAEvB;;;;;;;;AAQA,IAAAC,iBAAA;EAAA,SAAAA,kBAAA,GA4IA;EA3IEA,iBAAA,CAAAC,SAAA,CAAAC,MAAM,GAAN,UAAOC,OAAgB,EAAEC,OAAgB,EAAEC,MAAqB;;IAC9D,IAAMC,WAAW,GAAG,CAAAC,EAAA,GAAA7B,KAAK,CAAC8B,OAAO,CAACL,OAAO,CAAC,cAAAI,EAAA,uBAAAA,EAAA,CAAED,WAAW,EAAE;IACzD,IAAI,CAACA,WAAW,IAAI,CAAC1B,kBAAkB,CAAC0B,WAAW,CAAC,EAAE;IAEtD,IAAMG,SAAS,GAAGH,WAAW,CAACI,OAAO;IACrC,IAAMC,SAAS,GAAGF,SAAS,CAACG,SAAS,CAAC,CAAC,EAAEjB,0BAA0B,CAAC;IACpE,IAAMkB,YAAY,GAAGJ,SAAS,CAACG,SAAS,CAACjB,0BAA0B,CAAC;IAEpE,IAAMmB,QAAQ,GAAGR,WAAW,CAACS,MAAM;IACnC,IAAMC,YAAY,GAChB,CAACrC,UAAU,CAACsC,OAAO,GAAGX,WAAW,CAACY,UAAU,MAAMvC,UAAU,CAACsC,OAAO,GAChEnB,UAAU,GACVC,WAAW;IACjB;IAEA,IAAMoB,WAAW,GAAG,YAAUR,SAAS,SAAIE,YAAY,gBAAWC,QAAQ,iBAAYE,YAAc;IACpGX,MAAM,CAACe,GAAG,CAAChB,OAAO,EAAElB,uBAAuB,EAAEiC,WAAW,CAAC;EAC3D,CAAC;EAEDnB,iBAAA,CAAAC,SAAA,CAAAoB,OAAO,GAAP,UAAQlB,OAAgB,EAAEC,OAAgB,EAAEkB,MAAqB;IAC/D,IAAMhB,WAAW,GAAG,IAAI,CAACiB,wBAAwB,CAACnB,OAAO,EAAEkB,MAAM,CAAC;IAClE,IAAI,CAAC1C,kBAAkB,CAAC0B,WAAW,CAAC,EAAE,OAAOH,OAAO;IAEpD,OAAOzB,KAAK,CAAC8C,OAAO,CAACrB,OAAO,EAAEzB,KAAK,CAAC+C,eAAe,CAACnB,WAAW,CAAC,CAAC;EACnE,CAAC;EAEDN,iBAAA,CAAAC,SAAA,CAAAyB,MAAM,GAAN;IACE,OAAO,CAACxC,uBAAuB,CAAC;EAClC,CAAC;EAEOc,iBAAA,CAAAC,SAAA,CAAAsB,wBAAwB,GAAhC,UACEnB,OAAgB,EAChBkB,MAAqB;IAErB,IAAMK,UAAU,GAAGL,MAAM,CAACM,IAAI,CAACxB,OAAO,CAAC;IACvC,IAAMyB,iBAAiB,GAAGF,UAAU,CAACG,IAAI,CAAC,UAAAC,CAAC;MACzC,OAAOA,CAAC,CAACC,WAAW,EAAE,KAAK9C,uBAAuB;IACpD,CAAC,CAAC;IACF,IAAI,CAAC2C,iBAAiB,EAAE;MACtB,OAAO5C,oBAAoB;;IAE7B,IAAMkC,WAAW,GAAGG,MAAM,CAACW,GAAG,CAAC7B,OAAO,EAAEyB,iBAAiB,CAAC;IAE1D,IAAI,CAACV,WAAW,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE;MACnD,OAAOlC,oBAAoB;;IAG7B,IAAIiD,GAAG,GAAG,CAAC;IACX,IAAIC,WAAmB;IACvB,IAAIC,aAAa,GAAGrD,eAAe;IACnC,IAAIsD,YAAY,GAAGrD,cAAc;IACjC,IAAIsD,gBAAgB,GAAG,IAAI;IAC3B,OAAOJ,GAAG,GAAGf,WAAW,CAACoB,MAAM,EAAE;MAC/B,IAAMC,cAAc,GAAGrB,WAAW,CAACsB,OAAO,CAACtD,sBAAsB,EAAE+C,GAAG,CAAC;MACvE,IAAIM,cAAc,IAAI,CAAC,EAAE;QACvBL,WAAW,GAAGhB,WAAW,CAACP,SAAS,CAACsB,GAAG,EAAEM,cAAc,CAAC,CAACE,IAAI,EAAE;QAC/DR,GAAG,GAAGM,cAAc,GAAG,CAAC;OACzB,MAAM;QACL;QACAL,WAAW,GAAGhB,WAAW,CAACP,SAAS,CAACsB,GAAG,CAAC,CAACQ,IAAI,EAAE;QAC/CR,GAAG,GAAGf,WAAW,CAACoB,MAAM;;MAE1B,IAAMI,WAAW,GAAGR,WAAW,CAACM,OAAO,CAACrD,YAAY,CAAC;MAErD,IAAMwD,KAAK,GAAGT,WAAW,CAACvB,SAAS,CAAC+B,WAAW,GAAG,CAAC,CAAC;MAEpD,IAAIR,WAAW,CAACU,UAAU,CAACxD,YAAY,CAAC,EAAE;QACxC+C,aAAa,GAAGpC,iBAAiB,CAAC8C,aAAa,CAACF,KAAK,CAAC;OACvD,MAAM,IAAIT,WAAW,CAACU,UAAU,CAACjD,aAAa,CAAC,EAAE;QAChDyC,YAAY,GAAGrC,iBAAiB,CAAC+C,YAAY,CAACH,KAAK,CAAC;OACrD,MAAM,IAAIT,WAAW,CAACU,UAAU,CAAChD,gBAAgB,CAAC,EAAE;QACnDyC,gBAAgB,GAAGtC,iBAAiB,CAACgD,eAAe,CAACJ,KAAK,CAAC;;;IAG/D,IAAIN,gBAAgB,KAAK,IAAI,EAAE;MAC7B,OAAOrD,oBAAoB;;IAE7B,IAAMgE,iBAAiB,GAAgB;MACrCvC,OAAO,EAAE0B,aAAa;MACtBrB,MAAM,EAAEsB,YAAY;MACpBnB,UAAU,EAAEoB,gBAAgB;MAC5BY,QAAQ,EAAE;KACX;IACD,IAAI,CAACtE,kBAAkB,CAACqE,iBAAiB,CAAC,EAAE;MAC1C,OAAOhE,oBAAoB;;IAE7B,OAAOgE,iBAAiB;EAC1B,CAAC;EAEcjD,iBAAA,CAAA8C,aAAa,GAA5B,UAA6BK,WAAmB;IAC9C;IACA,IAAIA,WAAW,CAACZ,MAAM,KAAKjD,eAAe,EAAE;MAC1C,OAAOP,eAAe;;IAGxB;IACA,IAAI,CAACoE,WAAW,CAACN,UAAU,CAACtD,gBAAgB,CAAC,EAAE;MAC7C,OAAOR,eAAe;;IAGxB;IACA,IACEoE,WAAW,CAACC,MAAM,CAAC3D,0BAA0B,CAAC,KAAKD,kBAAkB,IACrE2D,WAAW,CAACC,MAAM,CAAC1D,0BAA0B,CAAC,KAAKF,kBAAkB,EACrE;MACA,OAAOT,eAAe;;IAGxB,IAAMsE,SAAS,GAAGF,WAAW,CAACvC,SAAS,CACrCnB,0BAA0B,GAAG,CAAC,EAC9BC,0BAA0B,CAC3B;IACD,IAAM4D,UAAU,GAAGH,WAAW,CAACvC,SAAS,CACtClB,0BAA0B,GAAG,CAAC,EAC9BJ,eAAe,CAChB;IACD,IAAMiE,UAAU,GAAGF,SAAS,GAAGC,UAAU;IAEzC;IACA,IAAI,CAACxE,cAAc,CAACyE,UAAU,CAAC,EAAE;MAC/B,OAAOxE,eAAe;;IAGxB,OAAOwE,UAAU;EACnB,CAAC;EAEcvD,iBAAA,CAAA+C,YAAY,GAA3B,UAA4BS,YAAoB;IAC9C,OAAO3E,aAAa,CAAC2E,YAAY,CAAC,GAAGA,YAAY,GAAGxE,cAAc;EACpE,CAAC;EAEcgB,iBAAA,CAAAgD,eAAe,GAA9B,UAA+BS,eAAuB;IACpD,IAAIA,eAAe,KAAK1D,WAAW,EAAE;MACnC,OAAOpB,UAAU,CAAC+E,IAAI;;IAExB,IAAID,eAAe,KAAK3D,UAAU,EAAE;MAClC,OAAOnB,UAAU,CAACsC,OAAO;;IAE3B,OAAO,IAAI;EACb,CAAC;EACH,OAAAjB,iBAAC;AAAD,CAAC,CA5ID","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}