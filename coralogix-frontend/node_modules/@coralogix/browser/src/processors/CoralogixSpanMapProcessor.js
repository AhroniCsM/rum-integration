import { CoralogixEventType, OtelNetworkAttrs, } from '../types';
import { CoralogixAttributes, CX_MAPPED_SPAN, NETWORK_URL_LABEL_PROVIDERS_KEY, PAGE_URL_LABEL_PROVIDERS_KEY, } from '../constants';
import { CoralogixLogSeverity } from '../types-external';
import { SDK_VERSION } from '../version';
import { applyUrlBluePrinters, deepClone, flattenAttributes, getInternalRumData, getUrlFragments, hrTimeToMilliseconds, parseUserAgent, } from '../utils';
import ErrorStackParser from 'error-stack-parser';
import { LONG_TASK_PERFORMANCE_TYPE, RESOURCES_INSTRUMENTATION_NAME, WEB_VITALS_INSTRUMENTATION_NAME, } from '../instrumentations/instrumentation.consts';
import { getSdkConfig, getSessionManager, getSessionRecorder, } from '../helpers';
import { shouldDropEvent } from '../filters/filters';
import { processBeforeSend } from '../before-send';
import { isProcessorShouldStop } from './processor.helper';
import { getNowTime } from '../utils/time';
export class CoralogixSpanMapProcessor {
    constructor() {
        this.sdkConfig = getSdkConfig();
        this.isActive = true;
    }
    onEnd(span) {
        var _a;
        if (isProcessorShouldStop(this.isActive)) {
            return;
        }
        const { onlySessionWithErrorMode, getPrevSession, getSession, setSession } = getSessionManager();
        const session = getSession() || setSession();
        const sessionHasRecording = !!((_a = getSessionRecorder()) === null || _a === void 0 ? void 0 : _a.getSessionHasRecording());
        const mappedCxSpan = this._mapToCxSpan(span, session, getPrevSession(), sessionHasRecording, onlySessionWithErrorMode);
        if (!shouldDropEvent(mappedCxSpan.text.cx_rum, this.sdkConfig)) {
            const resolvedCxSpan = processBeforeSend(mappedCxSpan, this.sdkConfig);
            if (resolvedCxSpan) {
                const isSeverityError = resolvedCxSpan.severity === CoralogixLogSeverity.Error;
                const sessionHasError = getSessionManager().sessionHasError;
                if (onlySessionWithErrorMode && (isSeverityError || sessionHasError)) {
                    getSessionManager().sessionHasError = true;
                    resolvedCxSpan.text.cx_rum.session_context.hasError = true;
                }
                span[CX_MAPPED_SPAN] = resolvedCxSpan;
            }
        }
    }
    onStart() { }
    shutdown() {
        this.isActive = false;
        return Promise.resolve();
    }
    forceFlush() {
        return Promise.resolve(undefined);
    }
    _mapToCxSpan(span, session, prevSession, sessionHasRecording, onlySessionWithErrorMode) {
        var _a, _b;
        const { sessionId, sessionCreationDate } = session || {};
        const { sessionId: prevSessionId, sessionCreationDate: prevSessionCreationDate, hasRecording: prevSessionHasRecording, } = prevSession || {};
        const { attributes, startTime, parentSpanId, name, endTime, status, duration, kind, } = span;
        const user_context = JSON.parse(attributes[CoralogixAttributes.USER_CONTEXT]);
        const application_context = JSON.parse(attributes[CoralogixAttributes.APPLICATION_CONTEXT]);
        const { application, version } = application_context;
        const eventType = attributes[CoralogixAttributes.EVENT_TYPE];
        const eventTypeContext = this._getEventTypeContext(attributes, eventType, span);
        const { spanId, traceId } = span.spanContext();
        const resourceAttributes = Object.assign(Object.assign({}, (_a = span.resource) === null || _a === void 0 ? void 0 : _a.attributes), { 'service.name': application });
        const labels = JSON.parse(attributes[CoralogixAttributes.CUSTOM_LABELS]);
        const isErrorWithStacktrace = !!((_b = eventTypeContext === null || eventTypeContext === void 0 ? void 0 : eventTypeContext.error_context) === null || _b === void 0 ? void 0 : _b.original_stacktrace);
        const version_metadata = {
            app_name: application,
            app_version: version,
        };
        const severity = (attributes === null || attributes === void 0 ? void 0 : attributes[CoralogixAttributes.SEVERITY]) ||
            CoralogixLogSeverity.Info;
        let timestamp = attributes[CoralogixAttributes.TIMESTAMP] || getNowTime();
        if (timestamp < sessionCreationDate) {
            timestamp = getNowTime();
        }
        const cxSpan = {
            version_metadata,
            applicationName: application,
            subsystemName: 'cx_rum',
            isErrorWithStacktrace,
            severity,
            timestamp,
            text: {
                cx_rum: Object.assign(Object.assign({ platform: 'browser', timestamp }, eventTypeContext), { browser_sdk: {
                        version: SDK_VERSION,
                    }, version_metadata, session_context: Object.assign(Object.assign(Object.assign(Object.assign({}, user_context), { session_id: sessionId, session_creation_date: sessionCreationDate, prev_session: prevSessionId
                            ? {
                                session_id: prevSessionId,
                                session_creation_date: prevSessionCreationDate,
                                hasRecording: prevSessionHasRecording,
                            }
                            : undefined, hasRecording: sessionHasRecording, user_agent: attributes[CoralogixAttributes.USER_AGENT] }), parseUserAgent(attributes[CoralogixAttributes.USER_AGENT])), { onlyWithErrorMode: onlySessionWithErrorMode }), page_context: span[CoralogixAttributes.PAGE_CONTEXT], isNavigationEvent: !!span[CoralogixAttributes.IS_NAVIGATION_EVENT], event_context: {
                        type: attributes[CoralogixAttributes.EVENT_TYPE],
                        source: attributes[CoralogixAttributes.SOURCE],
                        severity,
                    }, labels,
                    spanId,
                    traceId, environment: attributes[CoralogixAttributes.ENVIRONMENT] || '' }),
            },
        };
        if (eventType === CoralogixEventType.NETWORK_REQUEST) {
            cxSpan.instrumentation_data = {
                otelSpan: {
                    spanId,
                    traceId,
                    parentSpanId,
                    name,
                    attributes: flattenAttributes(attributes),
                    startTime,
                    endTime,
                    status,
                    kind,
                    duration,
                },
                otelResource: {
                    attributes: resourceAttributes,
                },
            };
        }
        cxSpan.text.cx_rum.labels = this.resolveLabels(cxSpan.text.cx_rum);
        return cxSpan;
    }
    _getEventTypeContext(spanAttributes, eventType, span) {
        var _a, _b;
        switch (eventType) {
            case CoralogixEventType.ERROR: {
                const errorMessage = spanAttributes[CoralogixAttributes.ERROR.MESSAGE];
                const stack = spanAttributes[CoralogixAttributes.ERROR.STACK];
                let originalStackTrace = undefined;
                if (stack) {
                    originalStackTrace = (_a = ErrorStackParser.parse({
                        stack: spanAttributes[CoralogixAttributes.ERROR.STACK],
                        message: errorMessage,
                        name: '',
                    })) === null || _a === void 0 ? void 0 : _a.map(({ fileName, columnNumber, lineNumber, functionName }) => ({
                        fileName,
                        columnNumber,
                        lineNumber,
                        functionName,
                    }));
                }
                return {
                    error_context: {
                        error_type: spanAttributes[CoralogixAttributes.ERROR.TYPE],
                        error_message: errorMessage,
                        original_stacktrace: originalStackTrace,
                    },
                };
            }
            case CoralogixEventType.NETWORK_REQUEST: {
                const url = spanAttributes[OtelNetworkAttrs.URL];
                const url_blueprint = applyUrlBluePrinters({
                    url,
                    blueprinters: (_b = this.sdkConfig.urlBlueprinters) === null || _b === void 0 ? void 0 : _b.networkUrlBlueprinters,
                });
                return {
                    network_request_context: {
                        method: spanAttributes[OtelNetworkAttrs.METHOD],
                        status_code: spanAttributes[OtelNetworkAttrs.STATUS_CODE],
                        url,
                        url_blueprint,
                        fragments: getUrlFragments(url_blueprint),
                        host: spanAttributes[OtelNetworkAttrs.HOST],
                        schema: spanAttributes[OtelNetworkAttrs.SCHEME],
                        status_text: spanAttributes[OtelNetworkAttrs.STATUS_TEXT],
                        duration: hrTimeToMilliseconds(span === null || span === void 0 ? void 0 : span.duration),
                        response_content_length: spanAttributes[OtelNetworkAttrs.RESPONSE_CONTENT_LENGTH],
                    },
                };
            }
            case CoralogixEventType.LOG: {
                if (spanAttributes[CoralogixAttributes.LOG]) {
                    const cxLog = JSON.parse(spanAttributes[CoralogixAttributes.LOG]);
                    return {
                        log_context: {
                            message: cxLog.message,
                            data: cxLog === null || cxLog === void 0 ? void 0 : cxLog.data,
                        },
                    };
                }
                return {
                    log_context: {
                        message: '',
                    },
                };
            }
            case CoralogixEventType.INTERNAL: {
                const internalContext = JSON.parse(spanAttributes[CoralogixAttributes.INTERNAL]);
                const { event, data } = internalContext || {};
                return {
                    internal_context: {
                        event,
                        data,
                    },
                };
            }
            case CoralogixEventType.USER_INTERACTION: {
                return {
                    interaction_context: {
                        target_element: spanAttributes[CoralogixAttributes.TARGET_ELEMENT],
                        event_name: spanAttributes[CoralogixAttributes.INTERACTION_EVENT_NAME],
                        target_element_inner_text: spanAttributes[CoralogixAttributes.ELEMENT_INNER_TEXT],
                        target_element_inner_html: spanAttributes[CoralogixAttributes.ELEMENT_INNER_HTML],
                        element_id: spanAttributes[CoralogixAttributes.ELEMENT_ID],
                        element_classes: spanAttributes[CoralogixAttributes.ELEMENT_CLASSES],
                        target_element_type: spanAttributes[CoralogixAttributes.TARGET_ELEMENT_TYPE],
                    },
                };
            }
            case CoralogixEventType.WEB_VITALS: {
                const webVitalsContext = JSON.parse(spanAttributes[WEB_VITALS_INSTRUMENTATION_NAME]);
                return {
                    web_vitals_context: webVitalsContext,
                };
            }
            case CoralogixEventType.LONG_TASK: {
                const longTaskContext = JSON.parse(spanAttributes[LONG_TASK_PERFORMANCE_TYPE]);
                return {
                    longtask_context: longTaskContext,
                };
            }
            case CoralogixEventType.RESOURCES: {
                const resourceContext = JSON.parse(spanAttributes[RESOURCES_INSTRUMENTATION_NAME]);
                return {
                    resource_context: resourceContext,
                };
            }
        }
        return {};
    }
    resolveLabels(cxRumEvent) {
        var _a, _b;
        let allLabels = cxRumEvent.labels;
        const labelProviders = (_a = this.sdkConfig) === null || _a === void 0 ? void 0 : _a.labelProviders;
        if (labelProviders === null || labelProviders === void 0 ? void 0 : labelProviders.length) {
            const pageUrlLabelProviders = getInternalRumData(PAGE_URL_LABEL_PROVIDERS_KEY);
            const networkUrlLabelProviders = getInternalRumData(NETWORK_URL_LABEL_PROVIDERS_KEY);
            const networkRequestFragment = (_b = cxRumEvent.network_request_context) === null || _b === void 0 ? void 0 : _b.fragments;
            const labelsFromProviders = Object.assign(Object.assign({}, this.getLabelsByLabelProviders(pageUrlLabelProviders, cxRumEvent, cxRumEvent.page_context.page_fragments)), (networkRequestFragment
                ? this.getLabelsByLabelProviders(networkUrlLabelProviders, cxRumEvent, networkRequestFragment)
                : {}));
            allLabels = Object.assign(Object.assign({}, allLabels), labelsFromProviders);
        }
        return allLabels;
    }
    getLabelsByLabelProviders(labelProviders, cxRumEvent, url) {
        let allLabels = {};
        const cxRumEventClone = deepClone(cxRumEvent);
        for (const labelProvider of labelProviders) {
            allLabels = Object.assign(Object.assign({}, allLabels), labelProvider.providerFunc(url, cxRumEventClone));
        }
        return allLabels;
    }
}
//# sourceMappingURL=CoralogixSpanMapProcessor.js.map