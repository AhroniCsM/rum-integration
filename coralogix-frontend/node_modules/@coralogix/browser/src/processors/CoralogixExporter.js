import { CORALOGIX_LOGS_URL_SUFFIX, CX_MAPPED_SPAN } from '../constants';
import { BATCH_TIME_DELAY } from '../session/session.consts';
import { ExportResultCode } from '@opentelemetry/core';
import { getSdkConfig, getSessionManager } from '../helpers';
import { MAX_RUM_EVENTS_PER_REQUEST } from '../session/sessionWithError.consts';
import { Request } from '../Request';
import { isSessionWithError } from '../session/session.helper';
import { isProcessorShouldStop } from './processor.helper';
export class CoralogixExporter {
    constructor() {
        this.isActive = true;
        this.sdkConfig = getSdkConfig();
        this.request = new Request({
            suffix: CORALOGIX_LOGS_URL_SUFFIX,
            headers: { 'Content-Type': 'application/json' },
        });
        this.batchTimeDelay = BATCH_TIME_DELAY;
        this.invokeLogRequest = (logs, markCachedLogsSent) => {
            if (logs === null || logs === void 0 ? void 0 : logs.length) {
                this.request
                    .send(JSON.stringify({
                    logs,
                    skip_enrichment_with_ip: !this.sdkConfig.collectIPData,
                }))
                    .then(() => {
                    if (markCachedLogsSent) {
                        getSessionManager().cachedLogsSent = true;
                    }
                });
            }
        };
    }
    export(spans, resultCallback) {
        if (isProcessorShouldStop(this.isActive)) {
            resultCallback({ code: ExportResultCode.SUCCESS });
            return;
        }
        const currentSpans = spans.reduce((cxSpans, span) => {
            if (span[CX_MAPPED_SPAN]) {
                cxSpans.push(span[CX_MAPPED_SPAN]);
            }
            return cxSpans;
        }, []);
        if (isSessionWithError()) {
            this.handleSessionWithError(currentSpans);
        }
        else {
            this.invokeLogRequest(currentSpans);
        }
        resultCallback({ code: ExportResultCode.SUCCESS });
    }
    handleSessionWithError(currentSpans) {
        const { maxRumEventsForSessionWithError, instrumentationsToSend, sessionHasError, } = getSessionManager();
        const instrumentationLogs = [];
        currentSpans = currentSpans.reduce((cxSpans, current) => {
            if (instrumentationsToSend &&
                instrumentationsToSend[current.text.cx_rum.event_context.type]) {
                instrumentationLogs.push(current);
            }
            else {
                cxSpans.push(current);
            }
            return cxSpans;
        }, []);
        this.invokeLogRequest(instrumentationLogs);
        const cachedLogs = (window.cachedLogs = [
            ...(window.cachedLogs || []),
            ...currentSpans,
        ]);
        const logsCounter = cachedLogs.length;
        //check if we reached the limit of max rum events for session with error
        if (logsCounter > maxRumEventsForSessionWithError && !sessionHasError) {
            this.clearCachedDataForSessionWithError();
        }
        else if (sessionHasError) {
            if (logsCounter > MAX_RUM_EVENTS_PER_REQUEST) {
                //split request to chunks of 500 logs per each
                const chunks = [];
                for (let i = 0; i < logsCounter; i += MAX_RUM_EVENTS_PER_REQUEST) {
                    chunks.push(cachedLogs.slice(i, i + MAX_RUM_EVENTS_PER_REQUEST));
                }
                chunks.forEach((chunk) => {
                    setTimeout(() => this.invokeLogRequest(chunk, true), this.batchTimeDelay);
                    this.batchTimeDelay += BATCH_TIME_DELAY;
                });
                this.clearCachedDataForSessionWithError();
            }
            else {
                this.invokeLogRequest(cachedLogs, true);
                this.clearCachedDataForSessionWithError();
            }
        }
    }
    clearCachedDataForSessionWithError() {
        window.cachedLogs = [];
        this.batchTimeDelay = BATCH_TIME_DELAY;
    }
    shutdown() {
        this.isActive = false;
        return Promise.resolve();
    }
}
//# sourceMappingURL=CoralogixExporter.js.map