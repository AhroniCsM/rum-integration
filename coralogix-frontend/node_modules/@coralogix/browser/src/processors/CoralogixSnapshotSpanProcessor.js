import { __rest } from "tslib";
import { CoralogixAttributes, CX_MAPPED_SPAN } from '../constants';
import { CoralogixEventType } from '../types';
import { getSessionRecorder, getSnapshotManager } from '../helpers';
import { CoralogixLogSeverity } from '../types-external';
import { isProcessorShouldStop } from './processor.helper';
import { getNowTime, millisecondsPerMinute } from '../utils/time';
export class CoralogixSnapshotSpanProcessor {
    constructor() {
        this.isActive = true;
    }
    forceFlush() {
        return Promise.resolve();
    }
    onEnd(span) {
        if (isProcessorShouldStop(this.isActive) || !span[CX_MAPPED_SPAN]) {
            return;
        }
        const cxSpan = span[CX_MAPPED_SPAN];
        if (this.isSnapshotPrepared(span)) {
            this.createSnapshot(cxSpan);
        }
        else {
            cxSpan.text.cx_rum.isSnapshotEvent = false;
        }
    }
    onStart(span, parentContext) { }
    shutdown() {
        this.isActive = false;
        return Promise.resolve();
    }
    createSnapshot(cxSpan) {
        const _a = getSnapshotManager().currentSnapshot, { timestamp } = _a, snapshotContext = __rest(_a, ["timestamp"]);
        cxSpan.text.cx_rum.isSnapshotEvent = true;
        cxSpan.text.cx_rum.snapshot_context = snapshotContext;
    }
    isSnapshotPrepared(span) {
        var _a;
        const { [CoralogixAttributes.TIMESTAMP]: spanTimestamp, [CoralogixAttributes.EVENT_TYPE]: spanType, [CoralogixAttributes.SEVERITY]: spanSeverity, } = span.attributes;
        let shouldCreateSnapshot = false;
        const { fragmentsState, updateSnapshot, currentSnapshot, isSnapshotSentDueToRecording, } = getSnapshotManager();
        const { timestamp: snapshotTimestamp, actionCount, errorCount, } = currentSnapshot;
        const pageContext = span[CoralogixAttributes.PAGE_CONTEXT];
        if (pageContext && !fragmentsState.has(pageContext.page_fragments)) {
            fragmentsState.add(pageContext.page_fragments);
            updateSnapshot({
                timestamp: getNowTime(),
                viewCount: fragmentsState.size,
            });
            shouldCreateSnapshot = true;
        }
        if (spanSeverity === CoralogixLogSeverity.Error) {
            updateSnapshot({
                timestamp: getNowTime(),
                errorCount: errorCount + 1,
            });
            shouldCreateSnapshot = true;
        }
        if (((_a = getSessionRecorder()) === null || _a === void 0 ? void 0 : _a.getSessionHasRecording()) &&
            !isSnapshotSentDueToRecording) {
            updateSnapshot({ timestamp: getNowTime(), hasRecording: true });
            getSnapshotManager().isSnapshotSentDueToRecording = true;
            shouldCreateSnapshot = true;
        }
        if (spanType === CoralogixEventType.DOM) {
            updateSnapshot({ timestamp: getNowTime() });
            shouldCreateSnapshot = true;
        }
        if (spanTimestamp - snapshotTimestamp >=
            millisecondsPerMinute) {
            updateSnapshot({ timestamp: getNowTime() });
            shouldCreateSnapshot = true;
        }
        if (spanType === CoralogixEventType.USER_INTERACTION) {
            updateSnapshot({ actionCount: actionCount + 1 });
        }
        return shouldCreateSnapshot;
    }
}
//# sourceMappingURL=CoralogixSnapshotSpanProcessor.js.map