import { InstrumentationBase, } from '@opentelemetry/instrumentation';
import { CSS_EXTENSIONS, DOC_EXTENSIONS, FONT_EXTENSIONS, FONTS_URL, IMG_EXTENSIONS, MEDIA_EXTENSIONS, OTHER_EXTENSIONS, RESOURCES_INSTRUMENTATION_NAME, RESOURCES_INSTRUMENTATION_VERSION, SCRIPT_EXTENSIONS, } from './instrumentation.consts';
import { CoralogixEventType, PerformanceTypes } from '../types';
import { CORALOGIX_LOGS_URL_SUFFIX, CoralogixAttributes, MAX_CHARACTERS, } from '../constants';
import { deepClone, supportedPerformanceTypes, valueEndWithOrInclude, } from '../utils';
import { resourceInitiatorTypeIs } from './instrumentation.helper';
import { ResourceInitiatorTypes } from './instrumentation.model';
import { getSdkConfig } from '../helpers';
export class CoralogixResourcesInstrumentation extends InstrumentationBase {
    constructor(config) {
        var _a;
        super(RESOURCES_INSTRUMENTATION_NAME, RESOURCES_INSTRUMENTATION_VERSION, config);
        this.ignoreUrls = (_a = getSdkConfig()) === null || _a === void 0 ? void 0 : _a.ignoreUrls;
        if (supportedPerformanceTypes[PerformanceTypes.Resource]) {
            this.registerToResources();
        }
        else {
            console.warn('Coralogix Browser SDK - browser doesnt support resource events');
        }
    }
    registerToResources() {
        this.resourcesObserver = new PerformanceObserver((list) => {
            list
                .getEntries()
                .reduce((mappedEntries, entry) => {
                const isNotFetchResourceType = entry.initiatorType !==
                    ResourceInitiatorTypes.Fetch;
                const isResourceNotContainsCoralogixLogsSuffix = !entry.name.includes(CORALOGIX_LOGS_URL_SUFFIX);
                const isResourceNotIgnored = !this.isResourceIgnored(entry.name);
                if ((isNotFetchResourceType ||
                    isResourceNotContainsCoralogixLogsSuffix) &&
                    isResourceNotIgnored) {
                    mappedEntries.push(this.mapResource(entry));
                }
                return mappedEntries;
            }, [])
                .forEach((entry) => {
                this.createSpanFromResource(entry);
            });
        });
        this.resourcesObserver.observe({
            type: PerformanceTypes.Resource,
            buffered: true,
        });
    }
    isResourceIgnored(resourceName) {
        var _a;
        if (!resourceName || !((_a = this.ignoreUrls) === null || _a === void 0 ? void 0 : _a.length)) {
            return false;
        }
        return this.ignoreUrls.some((url) => {
            if (url instanceof RegExp) {
                return url.test(resourceName);
            }
            else if (typeof url === 'string') {
                resourceName = resourceName.toLowerCase();
                url = url.toLowerCase();
                return url.includes(resourceName);
            }
            else {
                console.warn('Coralogix Browser SDK - ignoreUrls must be from type string | Regex');
                return false;
            }
        });
    }
    mapResource(resource) {
        const resourceName = resource.name;
        let initiatorType = resource.initiatorType;
        switch (true) {
            case resourceInitiatorTypeIs(initiatorType, [
                ResourceInitiatorTypes.Beacon,
            ]) || valueEndWithOrInclude(resourceName, OTHER_EXTENSIONS):
                initiatorType = ResourceInitiatorTypes.Other;
                break;
            case initiatorType !== ResourceInitiatorTypes.Css &&
                valueEndWithOrInclude(resourceName, CSS_EXTENSIONS):
                initiatorType = ResourceInitiatorTypes.Css;
                break;
            case initiatorType !== ResourceInitiatorTypes.Script &&
                valueEndWithOrInclude(resourceName, SCRIPT_EXTENSIONS):
                initiatorType = ResourceInitiatorTypes.Script;
                break;
            case initiatorType !== ResourceInitiatorTypes.Img &&
                valueEndWithOrInclude(resourceName, IMG_EXTENSIONS):
                initiatorType = ResourceInitiatorTypes.Img;
                break;
            case resourceName.includes(FONTS_URL) ||
                valueEndWithOrInclude(resourceName, FONT_EXTENSIONS):
                initiatorType = ResourceInitiatorTypes.Font;
                break;
            case initiatorType !== ResourceInitiatorTypes.Iframe &&
                valueEndWithOrInclude(resourceName, DOC_EXTENSIONS):
                initiatorType = ResourceInitiatorTypes.Doc;
                break;
            case resourceInitiatorTypeIs(initiatorType, [
                ResourceInitiatorTypes.Video,
                ResourceInitiatorTypes.Audio,
                ResourceInitiatorTypes.Track,
            ]) || valueEndWithOrInclude(resourceName, MEDIA_EXTENSIONS):
                initiatorType = ResourceInitiatorTypes.Media;
                break;
        }
        return Object.assign(Object.assign({}, deepClone(resource)), { initiatorType });
    }
    createSpanFromResource(entry) {
        var _a;
        const resourceSpan = this.tracer.startSpan(RESOURCES_INSTRUMENTATION_NAME);
        resourceSpan.setAttribute(CoralogixAttributes.EVENT_TYPE, CoralogixEventType.RESOURCES);
        const newEntry = Object.assign(Object.assign({}, deepClone(entry)), { name: (_a = entry.name) === null || _a === void 0 ? void 0 : _a.slice(0, MAX_CHARACTERS) });
        resourceSpan.setAttribute(RESOURCES_INSTRUMENTATION_NAME, JSON.stringify(newEntry));
        resourceSpan.end();
    }
    enable() { }
    disable() {
        var _a;
        (_a = this.resourcesObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    init() {
        return undefined;
    }
}
//# sourceMappingURL=CoralogixResourcesInstrumentation.js.map