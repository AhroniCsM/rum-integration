import { getElementXPath } from '@opentelemetry/sdk-trace-web';
import { InstrumentationBase, } from '@opentelemetry/instrumentation';
import { unwrap, wrap } from 'shimmer';
import { CoralogixAttributes } from '../constants';
import { CoralogixEventType } from '../types';
import { CoralogixLogSeverity } from '../types-external';
import { getCircularReplacer } from '../utils';
export const ERROR_INSTRUMENTATION_NAME = 'errors';
export const ERROR_INSTRUMENTATION_VERSION = '1';
export const ErrorAttributes = {
    TYPE: 'error_type',
    STACK: 'error_stack',
    MESSAGE: 'error_message',
};
export var ErrorSource;
(function (ErrorSource) {
    ErrorSource["CONSOLE"] = "console";
    ErrorSource["WINDOW"] = "window";
    ErrorSource["UNHANDLED_REJECTION"] = "unhandledrejection";
    ErrorSource["DOCUMENT"] = "document";
})(ErrorSource || (ErrorSource = {}));
const STACK_LIMIT = 4096;
const MESSAGE_LIMIT = 1024;
function addStackIfUseful(span, err) {
    const { stack } = err;
    const hasStack = !!(stack === null || stack === void 0 ? void 0 : stack.includes('at '));
    if (err && hasStack) {
        span.setAttribute(ErrorAttributes.STACK, stack.substring(0, STACK_LIMIT));
    }
}
const _consoleErrorHandler = (that) => {
    return (original) => (...args) => {
        that.report(ErrorSource.CONSOLE, args);
        return original.apply(that, args);
    };
};
const _errorListener = (that) => {
    return (event) => {
        that.report(ErrorSource.WINDOW, event);
    };
};
const _unhandledRejectionListener = (that) => {
    return (event) => {
        that.report(ErrorSource.UNHANDLED_REJECTION, event.reason);
    };
};
const _documentErrorListener = (that) => {
    return (event) => {
        that.report(ErrorSource.DOCUMENT, event);
    };
};
function addErrorDefaultAttributes(span) {
    span.setAttribute(CoralogixAttributes.EVENT_TYPE, CoralogixEventType.ERROR);
    span.setAttribute(CoralogixAttributes.SEVERITY, CoralogixLogSeverity.Error);
}
export class CoralogixErrorInstrumentation extends InstrumentationBase {
    constructor(config) {
        super(ERROR_INSTRUMENTATION_NAME, ERROR_INSTRUMENTATION_VERSION, config);
        this.parseErrorObject = (obj) => {
            var _a;
            return (_a = obj === null || obj === void 0 ? void 0 : obj.message) !== null && _a !== void 0 ? _a : JSON.stringify(obj, getCircularReplacer());
        };
        this.ignoreErrors = config.ignoreErrors;
    }
    init() { }
    enable() {
        wrap(console, 'error', _consoleErrorHandler(this));
        window.addEventListener('error', _errorListener(this));
        window.addEventListener('unhandledrejection', _unhandledRejectionListener(this));
        document.documentElement.addEventListener('error', _documentErrorListener(this), {
            capture: true,
        });
    }
    disable() {
        unwrap(console, 'error');
        window.removeEventListener('error', _errorListener(this));
        window.removeEventListener('unhandledrejection', _unhandledRejectionListener(this));
        document.documentElement.removeEventListener('error', _documentErrorListener(this), { capture: true });
    }
    report(source, arg) {
        if (arg instanceof Array) {
            if (arg.length === 0) {
                return;
            }
        }
        switch (true) {
            case arg instanceof Error:
                this.reportError(source, arg);
                break;
            case arg instanceof ErrorEvent:
                this.reportErrorEvent(source, arg);
                break;
            case arg instanceof Event:
                this.reportEvent(source, arg);
                break;
            case typeof arg === 'string':
                this.reportString(source, arg);
                break;
            case arg instanceof Array: {
                // if any arguments are Errors then add the stack trace even though the message is handled differently
                const firstError = arg.find((x) => x instanceof Error);
                const message = arg
                    .map((msg) => typeof msg === 'string' ? msg : this.parseErrorObject(msg))
                    .join(' ');
                this.reportString(source, message, firstError);
                break;
            }
            default:
                this.reportString(source, typeof arg === 'string' ? arg : this.getPossibleEventMessage(arg));
        }
    }
    reportError(source, err) {
        const { message, name } = err;
        const span = this.tracer.startSpan('error');
        const cleanMessage = message.split('\n')[0];
        addErrorDefaultAttributes(span);
        span.setAttribute(CoralogixAttributes.SOURCE, source);
        span.setAttribute(ErrorAttributes.TYPE, name);
        span.setAttribute(ErrorAttributes.MESSAGE, cleanMessage);
        addStackIfUseful(span, err);
        span.end();
    }
    reportString(source, message, firstError) {
        const span = this.tracer.startSpan(source);
        addErrorDefaultAttributes(span);
        span.setAttribute(CoralogixAttributes.SOURCE, source);
        span.setAttribute(ErrorAttributes.MESSAGE, message === null || message === void 0 ? void 0 : message.substring(0, MESSAGE_LIMIT));
        if (firstError) {
            addStackIfUseful(span, firstError);
        }
        span.end();
    }
    reportErrorEvent(source, { error, message }) {
        const event = error !== null && error !== void 0 ? error : message;
        this.report(source, event);
    }
    reportEvent(source, ev) {
        if (!ev.target) {
            return;
        }
        const span = this.tracer.startSpan(source);
        addErrorDefaultAttributes(span);
        span.setAttribute(CoralogixAttributes.SOURCE, source);
        if (ev.target) {
            span.setAttribute('target_element', ev.target.tagName);
            span.setAttribute('target_xpath', getElementXPath(ev.target, true));
            span.setAttribute('target_src', ev.target.src);
        }
        span.end();
    }
    getPossibleEventMessage(event) {
        const { message, statusMessage } = event || {};
        if (message && typeof message === 'string') {
            return message;
        }
        // GrpcStatusEvent
        if (statusMessage && typeof statusMessage === 'string') {
            return statusMessage;
        }
        return JSON.stringify(event);
    }
}
//# sourceMappingURL=CoralogixErrorInstrumentation.js.map