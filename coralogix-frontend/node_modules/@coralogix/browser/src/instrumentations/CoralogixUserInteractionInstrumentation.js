import { InstrumentationBase, } from '@opentelemetry/instrumentation';
import { CoralogixAttributes, MASKED_TEXT, MAX_INTERACTION_ELEMENT_SIZE, } from '../constants';
import { CoralogixEventType, } from '../types';
import { addEventListeners } from '../tools/addEventListener';
import { getSdkConfig } from '../helpers';
export const USER_INTERACTION_INSTRUMENTATION_NAME = 'user-interaction';
export const USER_INTERACTION_INSTRUMENTATION_VERSION = '1';
export const DEFAULT_INSTRUMENTED_EVENTS = {
    ["click" /* DOM_EVENT.CLICK */]: true,
};
export class CoralogixUserInteractionInstrumentation extends InstrumentationBase {
    constructor(config) {
        super(USER_INTERACTION_INSTRUMENTATION_NAME, USER_INTERACTION_INSTRUMENTATION_VERSION, config);
        this.handler = (_) => { };
        this.stop = () => { };
    }
    enable() {
        var _a;
        this.handler = (e) => {
            const eventTarget = e.target;
            const span = this.tracer.startSpan(USER_INTERACTION_INSTRUMENTATION_NAME);
            const config = getSdkConfig();
            const { innerText, innerHTML, id, type, value, className, nodeName } = eventTarget;
            const finalInnerHtml = this.shouldMaskByClass(config, className)
                ? MASKED_TEXT
                : innerHTML;
            span.setAttribute(CoralogixAttributes.EVENT_TYPE, CoralogixEventType.USER_INTERACTION);
            span.setAttribute(CoralogixAttributes.INTERACTION_EVENT_NAME, e.type);
            if (eventTarget && eventTarget instanceof HTMLElement) {
                const elementInnerText = () => {
                    const val = innerText || value || '';
                    if (this.shouldMaskElement(config, nodeName, className, type)) {
                        return MASKED_TEXT;
                    }
                    return typeof val === 'string' ? val : '';
                };
                [
                    [
                        CoralogixAttributes.ELEMENT_INNER_HTML,
                        (finalInnerHtml === null || finalInnerHtml === void 0 ? void 0 : finalInnerHtml.length) < MAX_INTERACTION_ELEMENT_SIZE
                            ? finalInnerHtml
                            : '',
                    ],
                    [CoralogixAttributes.ELEMENT_ID, id],
                    [CoralogixAttributes.ELEMENT_CLASSES, className],
                    [CoralogixAttributes.TARGET_ELEMENT_TYPE, type],
                    [
                        CoralogixAttributes.ELEMENT_INNER_TEXT,
                        elementInnerText().slice(0, MAX_INTERACTION_ELEMENT_SIZE),
                    ],
                    [CoralogixAttributes.TARGET_ELEMENT, nodeName],
                ].forEach(([key, value]) => {
                    span.setAttribute(key, value);
                });
            }
            span.end();
        };
        const eventsMap = Object.assign(Object.assign({}, DEFAULT_INSTRUMENTED_EVENTS), (_a = this._config) === null || _a === void 0 ? void 0 : _a['events']);
        const eventNames = Object.entries(eventsMap)
            .filter(([_, enabled]) => enabled)
            .map(([eventName]) => eventName);
        this.stop = addEventListeners(document, eventNames, this.handler, {
            capture: true,
            passive: true,
        }).stop;
    }
    shouldMaskElement(config, nodeName, className, type) {
        const { maskInputTypes, maskClass } = config;
        const shouldMaskByInput = nodeName === 'INPUT' && maskInputTypes.includes(type);
        const shouldMaskByClass = this.shouldMaskByClass(config, className);
        return shouldMaskByInput || shouldMaskByClass;
    }
    shouldMaskByClass(config, className) {
        const { maskClass } = config;
        if (maskClass instanceof RegExp) {
            return maskClass.test(className);
        }
        if (typeof className === 'string') {
            return className.includes(maskClass);
        }
        return false;
    }
    disable() {
        this.stop();
    }
    init() {
        return undefined;
    }
}
//# sourceMappingURL=CoralogixUserInteractionInstrumentation.js.map