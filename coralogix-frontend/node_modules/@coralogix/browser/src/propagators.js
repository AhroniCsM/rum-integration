import { __awaiter } from "tslib";
export function handlePropagators(config, tracerProvider) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        if ((_a = config.traceParentInHeader) === null || _a === void 0 ? void 0 : _a.enabled) {
            let propagators = [];
            const { CompositePropagator, W3CBaggagePropagator, W3CTraceContextPropagator, } = yield import('@opentelemetry/core');
            const { propagateB3TraceHeader, propagateAwsXrayTraceHeader } = ((_b = config.traceParentInHeader) === null || _b === void 0 ? void 0 : _b.options) || {};
            if (!propagateAwsXrayTraceHeader && !propagateB3TraceHeader) {
                propagators = [
                    ...propagators,
                    new W3CBaggagePropagator(),
                    new W3CTraceContextPropagator(),
                ];
            }
            if (propagateAwsXrayTraceHeader) {
                const { AWSXRayPropagator } = yield import('@opentelemetry/propagator-aws-xray');
                propagators.push(new AWSXRayPropagator());
            }
            if (propagateB3TraceHeader) {
                const { B3InjectEncoding, B3Propagator } = yield import('@opentelemetry/propagator-b3');
                const { singleHeader, multiHeader } = propagateB3TraceHeader;
                if (singleHeader) {
                    propagators.push(new B3Propagator());
                }
                if (multiHeader) {
                    propagators.push(new B3Propagator({ injectEncoding: B3InjectEncoding.MULTI_HEADER }));
                }
            }
            tracerProvider.register({
                propagator: new CompositePropagator({
                    propagators,
                }),
            });
        }
    });
}
//# sourceMappingURL=propagators.js.map