import { __rest } from "tslib";
import { isNil } from './general';
import { coerceArray } from './array';
export function isObject(value) {
    return typeof value === 'object';
}
/**
 * Creates an object composed of the properties of the input object, excluding the specified paths.
 *
 * @param object The source object from which to omit properties.
 * @param paths An array or a single path (including nested paths) to omit from the source object.
 * @returns Returns a new object with the specified paths omitted.
 */
export function omit(object = {}, ...paths) {
    if (isNil(object))
        return {};
    const omitter = (source, pathArray) => {
        const [firstKey, ...remainingKeys] = pathArray;
        if (!source.hasOwnProperty(firstKey))
            return source;
        if (!remainingKeys.length) {
            const _a = source, _b = firstKey, _ = _a[_b], rest = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            return rest;
        }
        return Object.assign(Object.assign({}, source), { [firstKey]: omitter(source[firstKey], remainingKeys) });
    };
    //@ts-ignore
    return coerceArray(paths).reduce((result, path) => omitter(result, path.split('.')), object);
}
/**
 * Creates an object composed of the picked object properties, including support for nested paths.
 *
 * @param object The source object from which to pick properties.
 * @param keys An array or a single key (including nested paths) to pick from the source object.
 * @returns Returns a new object with properties picked from the source object.
 */
export function pick(object = {}, ...keys) {
    const picker = (source, pathArray) => {
        const [firstKey, ...remainingKeys] = pathArray;
        if (!source.hasOwnProperty(firstKey))
            return undefined;
        if (!remainingKeys.length) {
            return { [firstKey]: source[firstKey] };
        }
        const nestedValue = picker(source[firstKey], remainingKeys);
        if (nestedValue === undefined) {
            return undefined;
        }
        return { [firstKey]: nestedValue };
    };
    let result = {};
    coerceArray(keys).forEach((key) => {
        result = Object.assign(Object.assign({}, result), picker(object, key.split('.')));
    });
    return result;
}
/**
 * Checks if a Set, Array, Map, or Object is empty.
 *
 * @param value - The value to check.
 * @returns Returns true if the value is an empty Set, Map, Array, String or Object, else false.
 */
export function isEmpty(value) {
    if (isNil(value))
        return true;
    if (value instanceof Set || value instanceof Map) {
        return value.size === 0;
    }
    if (Array.isArray(value) || typeof value === 'string') {
        return value.length === 0;
    }
    if (isObject(value)) {
        return Object.keys(value).length === 0;
    }
    return false;
}
/**
 * Checks if a Set, Array, Map, or Object is not empty.
 *
 * @param value - The value to check.
 * @returns Returns false if the value is an empty Set, Map, Array, String or Object, else true.
 */
export function isNotEmpty(value) {
    return !isEmpty(value);
}
//# sourceMappingURL=object.js.map