import { SessionRecorder } from './sessionRecorder';
import { getSdkConfig, getSessionRecorder, getSnapshotManager, } from '../helpers';
import { PREV_SESSION_KEY, SESSION_EXPIRATION_TIME, SESSION_IDLE_TIME, SESSION_KEY, SESSION_MANAGER_KEY, } from './session.consts';
import { isSamplingOn } from './session.helper';
import { generateUUID } from '../utils';
import { SessionIdle } from './session-idle';
import { getNowTime } from '../utils/time';
export class SessionManager extends SessionIdle {
    constructor(recordConfig) {
        super({
            timeoutDelay: SESSION_IDLE_TIME,
            onIdle: () => this.clearSessionWhenIdle(),
            onActive: () => this.setSession(true),
        });
        this._sessionConfig = getSdkConfig().sessionConfig;
        this._sessionHasError = false;
        this._cachedLogsSent = false;
        this.getPrevSession = () => {
            return JSON.parse(window.sessionStorage.getItem(PREV_SESSION_KEY));
        };
        this.getSession = () => {
            const storedSession = JSON.parse(window.sessionStorage.getItem(SESSION_KEY));
            const now = getNowTime();
            let session;
            if (storedSession) {
                if (storedSession.sessionExpirationDate > now) {
                    session = storedSession;
                }
                else {
                    this.clearSessionWhenIdle();
                    session = this.setSession(true);
                }
            }
            return session;
        };
        this.setSession = (afterIdle = false, sessionId) => {
            var _a, _b;
            const now = getNowTime();
            const session = {
                sessionId: sessionId || generateUUID(),
                sessionCreationDate: now,
                sessionExpirationDate: now + SESSION_EXPIRATION_TIME,
            };
            this.activeSession = session;
            window.sessionStorage.setItem(SESSION_KEY, JSON.stringify(session));
            const sessionRecorder = getSessionRecorder();
            const shouldStartRecordingAfterIdle = afterIdle &&
                !!(sessionRecorder === null || sessionRecorder === void 0 ? void 0 : sessionRecorder.recordingStopDueToTimeout) &&
                !!((_a = this.sessionRecorderConfig) === null || _a === void 0 ? void 0 : _a.enable);
            if (shouldStartRecordingAfterIdle ||
                (sessionRecorder === null || sessionRecorder === void 0 ? void 0 : sessionRecorder.getIsAutoStartRecording())) {
                (_b = this.sessionRecorder) === null || _b === void 0 ? void 0 : _b.startRecording();
            }
            return session;
        };
        window[SESSION_MANAGER_KEY] = this;
        this.sessionRecorderConfig = recordConfig;
        if (recordConfig === null || recordConfig === void 0 ? void 0 : recordConfig.enable) {
            const recordingSamplingEnabled = isSamplingOn(recordConfig.sessionRecordingSampleRate);
            if (recordingSamplingEnabled) {
                this.sessionRecorder = new SessionRecorder(this, recordConfig);
            }
            else {
                if (getSdkConfig().debug) {
                    console.debug('Coralogix Browser SDK - Session recording is disabled');
                }
            }
        }
    }
    get currentPageFragment() {
        return this._currentPageFragment;
    }
    set currentPageFragment(value) {
        // Should not set currentPageFragment when idle even if rum events are sent before idle(like network requests)
        this._currentPageFragment = this.isIdleActive ? undefined : value;
    }
    get sessionConfig() {
        return this._sessionConfig;
    }
    get onlySessionWithErrorMode() {
        return this._sessionConfig.onlyWithErrorConfig.enable;
    }
    get maxRumEventsForSessionWithError() {
        return this._sessionConfig.onlyWithErrorConfig.maxRumEvents || 0;
    }
    get maxRecordTimeForSessionWithError() {
        return this._sessionConfig.onlyWithErrorConfig.maxRecordTime || 0;
    }
    get instrumentationsToSend() {
        return this._sessionConfig.onlyWithErrorConfig.instrumentationsToSend;
    }
    get cachedLogsSent() {
        return this._cachedLogsSent;
    }
    get sessionHasError() {
        return this._sessionHasError;
    }
    set sessionHasError(value) {
        this._sessionHasError = value;
    }
    set cachedLogsSent(val) {
        this._cachedLogsSent = val;
    }
    getSessionKey() {
        return SESSION_KEY;
    }
    getActiveSession() {
        return this.activeSession;
    }
    start() {
        this.startIdleListener();
        this.clearPrevSession();
        this.setSession();
    }
    stop() {
        this.stopIdleListener();
    }
    clearSessionWhenIdle() {
        var _a;
        if ((_a = this.sessionRecorder) === null || _a === void 0 ? void 0 : _a.getSessionHasRecording()) {
            this.sessionRecorder.recordingStopDueToTimeout = true;
        }
        this.clearSession();
    }
    clearPrevSession() {
        window.sessionStorage.removeItem(PREV_SESSION_KEY);
    }
    clearSession() {
        var _a, _b, _c;
        window.sessionStorage.setItem(PREV_SESSION_KEY, JSON.stringify(Object.assign(Object.assign({}, this.activeSession), { hasRecording: (_a = this.sessionRecorder) === null || _a === void 0 ? void 0 : _a.getSessionHasRecording() })));
        this.clearSessionWithErrorMode();
        (_b = getSnapshotManager()) === null || _b === void 0 ? void 0 : _b.resetSnapshot();
        this._currentPageFragment = undefined;
        (_c = this.sessionRecorder) === null || _c === void 0 ? void 0 : _c.stopRecording();
        window.sessionStorage.removeItem(SESSION_KEY);
    }
    clearSessionWithErrorMode() {
        this.sessionHasError = false;
        this.cachedLogsSent = false;
    }
}
//# sourceMappingURL=sessionManager.js.map