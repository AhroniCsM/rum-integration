import { __awaiter } from "tslib";
import { EventType } from '@rrweb/types';
import { BATCH_TIME_DELAY, MAX_BATCH_TIME_MS, MAX_MUTATIONS_FOR_SESSION_RECORDING, SESSION_RECORDER_KEY, SESSION_RECORDING_DEFAULT_ERROR_MESSAGE, SESSION_RECORDING_DEFAULT_HEADERS, SESSION_RECORDING_NETWORK_ERR0R_MESSAGE, SESSION_RECORDING_POSTFIX_URL, } from './session.consts';
import { getSdkConfig } from '../helpers';
import { getWorkerString } from '../workers/session-recording-worker';
import { record } from 'rrweb';
import { reportInternalEvent } from '../internal-event-reporter';
import { Request } from '../Request';
import { getRecordConsolePlugin } from '@rrweb/rrweb-plugin-console-record';
import { getNowTime } from '../utils/time';
export class SessionRecorder {
    constructor(sessionManager, recordConfig) {
        var _a;
        this.isAutoStartRecording = false;
        this.onlySessionWithErrorMode = false;
        this.recordEvents = [];
        this.recordEventsForSessionWithError = [[], []];
        this.segmentIndexCounter = {};
        this.hasRecording = false;
        this.recordingStopped = false;
        this.batchTimeDelay = BATCH_TIME_DELAY;
        this.isErrorOccurred = false;
        this.debugMode = !!((_a = getSdkConfig()) === null || _a === void 0 ? void 0 : _a.debug);
        this._recordingStopDueToTimeout = false;
        this.handleRecordEvent = (event, isCheckout) => {
            if (!this.recordingStopped) {
                if (this.onlySessionWithErrorMode) {
                    this.handleRecordEventForSessionWithError(event, isCheckout);
                }
                else {
                    this.recordEvents.push(event);
                }
            }
        };
        this.prepareRecordEventsBeforeSend = () => {
            if (this.onlySessionWithErrorMode) {
                this.prepareRecordEventsForSessionWithError();
            }
            else {
                if (!this.recordEvents.length) {
                    return;
                }
                this.compressRecordData(this.recordEvents);
                this.resetBatching();
            }
        };
        this.sendRecordEvents = (sessionId, sessionCreationTime, data, chunkIndex, totalChunks, dataSplit) => {
            const formData = new FormData();
            const { application } = getSdkConfig();
            let segmentIndex;
            if (!this.segmentIndexCounter[sessionId]) {
                this.segmentIndexCounter[sessionId] = 0;
            }
            if (dataSplit) {
                segmentIndex =
                    chunkIndex === totalChunks
                        ? this.segmentIndexCounter[sessionId]++
                        : this.segmentIndexCounter[sessionId];
            }
            else {
                segmentIndex = this.segmentIndexCounter[sessionId]++;
            }
            const metaData = {
                segmentIndex,
                segmentSize: data.size,
                segmentTimestamp: getNowTime(),
                sessionCreationTime,
                sessionId,
                application,
                subIndex: chunkIndex !== null && chunkIndex !== void 0 ? chunkIndex : -1,
            };
            formData.append('chunk', data);
            formData.append('metaData', JSON.stringify(metaData));
            const sendRecordRequest = () => __awaiter(this, void 0, void 0, function* () {
                var _a;
                try {
                    const response = !this.isErrorOccurred
                        ? yield ((_a = this.request) === null || _a === void 0 ? void 0 : _a.send(formData))
                        : undefined;
                    this.handleSessionRecordingResponse(response);
                }
                catch (error) {
                    this.handleSessionRecordingResponse(undefined);
                    // todo: send internal error after sessions changes issues resolve
                    // reportInternalEvent('error', error?.message);
                }
            });
            if (dataSplit) {
                this.batchTimeout = setTimeout(sendRecordRequest, this.batchTimeDelay);
                this.batchTimeDelay += BATCH_TIME_DELAY;
            }
            else {
                sendRecordRequest();
                this.batchTimeDelay = BATCH_TIME_DELAY;
            }
        };
        window[SESSION_RECORDER_KEY] = this;
        this.sessionManager = sessionManager;
        const { onlySessionWithErrorMode, maxRecordTimeForSessionWithError } = sessionManager;
        const { maxMutations, autoStartSessionRecording } = recordConfig;
        this.onlySessionWithErrorMode = onlySessionWithErrorMode;
        this.maxRecordTimeForSessionWithError = maxRecordTimeForSessionWithError;
        this.isAutoStartRecording = autoStartSessionRecording;
        this.maxMutations = maxMutations !== null && maxMutations !== void 0 ? maxMutations : MAX_MUTATIONS_FOR_SESSION_RECORDING;
        this.recordConfig = this.prepareRecordConfig(recordConfig);
        if (window.Worker) {
            try {
                const workerCode = `(${getWorkerString.toString()})()`;
                const workerUrl = URL.createObjectURL(new Blob([workerCode]));
                this.sessionWorker = new Worker(workerUrl);
                if (this.isAutoStartRecording) {
                    this.startRecording();
                }
                this.request = new Request({
                    suffix: SESSION_RECORDING_POSTFIX_URL,
                    headers: SESSION_RECORDING_DEFAULT_HEADERS,
                });
                this.registerToWorkerMessages();
            }
            catch (err) {
                if (this.debugMode) {
                    console.warn('Coralogix Browser SDK - Web worker not created due to: ', err);
                }
            }
        }
        else {
            if (this.debugMode) {
                console.warn(SESSION_RECORDING_DEFAULT_ERROR_MESSAGE);
            }
        }
    }
    getSessionHasRecording() {
        var _a;
        return (this.hasRecording &&
            !!this.segmentIndexCounter[(_a = this.sessionManager.getActiveSession()) === null || _a === void 0 ? void 0 : _a.sessionId]);
    }
    getIsAutoStartRecording() {
        return this.isAutoStartRecording;
    }
    set recordingStopDueToTimeout(value) {
        this._recordingStopDueToTimeout = value;
    }
    get recordingStopDueToTimeout() {
        return this._recordingStopDueToTimeout;
    }
    startRecording() {
        if (!this.sessionWorker || this.recordRef) {
            return;
        }
        if (this.debugMode) {
            console.log('Coralogix Browser SDK - Session recording started');
        }
        this.startMutationObserver();
        this.resetBatching();
        this.hasRecording = true;
        this.recordingStopped = false;
        this.isErrorOccurred = false;
        this.recordingStopDueToTimeout = false;
        this.recordRef = record(this.recordConfig);
        this.startBatchingRecords();
    }
    stopRecording() {
        if (!this.recordRef) {
            return;
        }
        if (this.debugMode) {
            console.log('Coralogix Browser SDK - Session recording stopped');
        }
        this.recordRef();
        this.recordRef = undefined;
        this.recordingStopped = true;
        this.hasRecording = false;
        this.prepareRecordEventsBeforeSend();
        this.clearIntervals();
        this.stopMutationObserver();
    }
    stopMutationObserver() {
        var _a;
        (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    startMutationObserver() {
        this.stopMutationObserver();
        this.mutationObserver = new MutationObserver((mutations) => {
            if (mutations.length > this.maxMutations) {
                const message = `Coralogix Browser SDK - Recording stopped due to too many mutations ${mutations.length}`;
                console.warn(message);
                reportInternalEvent('recording-stop', message);
                this.stopRecording();
            }
        });
        this.mutationObserver.observe(document, {
            attributes: false,
            attributeOldValue: false,
            characterData: false,
            characterDataOldValue: false,
            childList: true,
            subtree: true,
        });
    }
    clearIntervals() {
        if (this.batchingTimeInterval) {
            clearInterval(this.batchingTimeInterval);
        }
    }
    prepareRecordConfig(recordConfig) {
        var _a;
        const { excludeDOMOptions, recordConsoleEvents } = recordConfig || {};
        // @ts-ignore
        this.recordConfig = Object.assign(Object.assign({}, recordConfig), { emit: this.handleRecordEvent, checkoutEveryNms: this.onlySessionWithErrorMode
                ? this.maxRecordTimeForSessionWithError
                : undefined, slimDOMOptions: Object.assign(Object.assign({}, excludeDOMOptions), { script: (_a = excludeDOMOptions === null || excludeDOMOptions === void 0 ? void 0 : excludeDOMOptions.script) !== null && _a !== void 0 ? _a : true }), plugins: recordConsoleEvents ? [getRecordConsolePlugin()] : [] });
        return this.recordConfig;
    }
    handleRecordEventForSessionWithError(event, isCheckout) {
        const shouldIgnoreEvent = this.sessionManager.sessionHasError &&
            !!isCheckout &&
            event.type === EventType.FullSnapshot;
        if (shouldIgnoreEvent) {
            return;
        }
        const shouldAddNewSnapshot = !!isCheckout && event.type === EventType.Meta;
        // Add new snapshot to the cache
        if (shouldAddNewSnapshot) {
            this.recordEventsForSessionWithError.push([]);
        }
        const { length, [length - 1]: lastEvents } = this.recordEventsForSessionWithError;
        lastEvents.push(event);
    }
    prepareRecordEventsForSessionWithError() {
        const { length, [length - 2]: beforeLast, [length - 1]: last, } = this.recordEventsForSessionWithError;
        if (this.sessionManager.sessionHasError) {
            const lastEvents = beforeLast.concat(last);
            if (!lastEvents.length) {
                return;
            }
            this.compressRecordData(lastEvents);
            this.resetBatching();
        }
        else {
            // If no error occurred, we need to keep only the last 2 snapshots
            this.recordEventsForSessionWithError = [beforeLast, last];
        }
    }
    compressRecordData(recordEvents) {
        const { sessionId, sessionCreationDate } = this.sessionManager.getActiveSession() || {};
        this.sessionWorker.postMessage({
            event: 'compressRecordData',
            records: recordEvents,
            sessionId,
            sessionCreationDate,
        });
    }
    registerToWorkerMessages() {
        this.sessionWorker.onmessage = ({ data, }) => {
            switch (data.event) {
                case 'sendRecordData':
                    this.sendRecordEvents(data.sessionId, data.sessionCreationDate, data.gzipBlob);
                    break;
                case 'splitRecordData':
                    this.sendRecordEvents(data.sessionId, data.sessionCreationDate, data.gzipBlob, data.chunkIndex, data.totalChunks, true);
                    break;
                case 'stopRecording':
                    this.stopRecording();
                    break;
            }
        };
    }
    resetBatching() {
        if (this.onlySessionWithErrorMode) {
            this.recordEventsForSessionWithError = [[], []];
        }
        else {
            this.recordEvents = [];
        }
    }
    handleSessionRecordingResponse(response) {
        if (!(response === null || response === void 0 ? void 0 : response.ok) && !this.isErrorOccurred) {
            console.warn(SESSION_RECORDING_NETWORK_ERR0R_MESSAGE);
            this.isErrorOccurred = true;
            this.stopRecording();
            if (this.batchTimeout) {
                clearTimeout(this.batchTimeout);
            }
        }
        else {
            this.isErrorOccurred = false;
        }
    }
    startBatchingRecords() {
        this.batchingTimeInterval = setInterval(this.prepareRecordEventsBeforeSend, MAX_BATCH_TIME_MS);
    }
}
//# sourceMappingURL=sessionRecorder.js.map